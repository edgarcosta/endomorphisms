/***
 *  Chinese remainderings of fractions
 *
 *  Copyright (C) 2016-2017
 *            Edgar Costa      (edgarcosta@math.dartmouth.edu)
 *            Davide Lombardo  (davide.lombardo@math.u-psud.fr)
 *            Jeroen Sijsling  (jeroen.sijsling@uni-ulm.de)
 *
 *  See LICENSE.txt for license details.
 */


forward RandomSplitPrime;

forward FractionalCRTQQ;
forward FractionalCRTSplit;

forward ReduceConstantSplit;
forward ReducePointSplit;
forward ReduceMatrixSplit;
forward ReducePolynomialSplit;
forward ReduceRationalFunctionSplit;
forward ReduceBasisOfDifferentialsSplit;
forward ReduceAffinePatchSplit;
forward ReduceCurveSplit;

intrinsic Dimensions(P::AlgMat) -> RngIntElt, RngIntElt
{ the dimensions of the matrices of its elements }
    return Degree(P), Degree(P);
end intrinsic;

intrinsic Dimensions(P::ModMatRng) -> RngIntElt, RngIntElt
{ the dimensions of the matrices of its elements }
    return Rank(Domain(P)), Rank(Codomain(P));
end intrinsic;


intrinsic RationalReconstruction(x::RngOrdElt, I::RngOrdIdl) -> BoolElt, FldElt
{
    Given an element x modulu I, attempts to rational reconstruct via LLL.
    Returns true and the field element if succeeds, otherwise false.
}
    O := Order(I);
    K := NumberField(O);
    d := Degree(O);
    M := Matrix(Integers(), [[0] cat Eltseq(b) : b in Basis(I) ] cat [[1] cat Eltseq(x)]);
    v := Basis(LLL(Lattice(M)))[1];
    if v[1] eq 0 then return false, _; end if;
    n := &+[ v[i+1] * b : i->b in Basis(O) ];
    d := v[1];
    assert d*x - n in I;
    return true, K!(1/d)*n;
end intrinsic;


function RandomSplitPrime(f, B)
/*
 * Input:  A polynomial f over K and a positive integer B
 * Output: A totally split prime in K of size roughly 2^B
 *         that stays totally split in the extension generated by f
 */

K := BaseRing(Parent(f));
if Type(K) eq FldRat then OK := Integers(); else OK := EquationOrder(K); end if;

while true do
    repeat p := RandomPrime(B : Proof := false); until p^2 ge B;
    FF := FiniteField(p);

    if Type(K) eq FldRat then
        test := true; rt := 1;
    else
        test, rt := HasRoot(MinimalPolynomial(K.1, Rationals()), FF);
    end if;

    if test then
        pr := ideal<OK | [ p, (OK ! K.1) - (OK ! (Integers() ! rt)) ]>;
        /* This calculation costs quite some time */
        FF, h := ResidueClassField(pr);
        f_red := ReducePolynomialSplit(f, h);
        /* We demand full splitting because in the end we have to work with all
         * branches while iterating, and that is better over a prime field */
        if #Roots(f_red) eq Degree(f_red) then
            return pr, h;
        end if;
    end if;
end while;

end function;

function FractionalCRTQQMatrix(rs, ps)
    /* rs is a set of remainders at the set of primes ps */
    ps := [ Norm(p) : p in ps ];
    I := &*ps;
    I := Norm(I);
    // coerce rs to the integers
    n, m := Dimensions(Universe(rs));
    rs := [ RMatrixSpace(IntegerRing(), n, m) | r : r in rs ];
    x := CRT(rs, ps);
    nb, db := x, x where x := Isqrt(I div 2);
    xQQ := RationalReconstruction(x, I, nb, db, Rationals(), <1, 1>);
    if Type(xQQ) eq RngIntElt then
        assert xQQ eq 0;
        return false, _;
    end if;
    return true, xQQ;
end function;

function FractionalCRTQQ(rs, ps)
/* rs is a set of remainders at the set of primes ps */
    rs := [ Matrix(Integers(), [[r]]) : r in rs ];
    b, r := FractionalCRTQQMatrix(rs, ps);
    if b then
        return true, r[1,1];
    else
        return false, _;
    end if;
end function;

function FractionalCRTSplitMatrix(rs, ps)
    OK := Order(ps[1]);
    K := NumberField(OK);
    norms := [Norm(p) : p in ps];
    // expect all prime fields
    assert &and [IsPrime(np) : np in norms];
    if Type(K) eq FldRat or Degree(K) eq 1 then
        // FIXME I might need to do some conversion in the later case
        return FractionalCRTQQMatrix(rs, ps);
    end if;
    I := &*ps;

    // By the 3rd isomorphism theorem, we can work in Z/N = (Z[x]/f(x))/(<N, x - r>/f(x))
    // where f(r) = 0 mod N and N = &*||p||
    assert #SequenceToSet(norms) eq #norms; // to be generalized later
    rN := ChangeRing(CRT(rs, norms), OK);
    n, m := Nrows(rN), Ncols(rN);
    res := ZeroMatrix(K, n, m);
    for i in [1..n], j in [1..m] do
        b, res[i,j] := RationalReconstruction(rN[i,j], I);
        if not b then
            return false, _;
        end if;
    end for;
    return true, res;
end function;



function FractionalCRTSplit(rs, ps);
/* rs is a set of remainders at the set of split primes ps
 * The product of these primes equals I: it can be passed as an argument to
 * avoid recalculation */

OK := Order(ps[1]); K := NumberField(OK);
if Type(K) eq FldRat or Degree(K) eq 1 then return FractionalCRTQQ(rs, ps); end if;
I := &*ps;
BOK := Basis(OK);
BI := Basis(I);

// By the 3rd isomorphism theorem, we can work in Z/N = (Z[x]/f(x))/(<N, x - r>/f(x)) where f(r) = 0 mod N and N = &*||p||
/* Find n that works */
n := CRT([ Integers() ! r : r in rs ], [ Norm(p) : p in ps ]);
/* Same approach as in previous function generalized */
M := Matrix(Integers(), [ [ b[i] : b in BOK ] cat [ KroneckerDelta(1, i)*n ] cat [ b[i] : b in BI ] : i in [1..#BOK] ]);
Lat := Lattice(Kernel(Transpose(M)));
v := Basis(LLL(Lat))[1];
if v[#BOK + 1] ne 0 then
    return true, K ! ( (-1/v[#BOK + 1]) * &+[ v[i] * BOK[i] : i in [1..#BOK] ] );
end if;
return false, _;

end function;


function FractionalCRTSplitPolynomials(reductions, primes)
    // expect the same number polynomials at each prime
    assert #{#rs : rs in reductions} eq 1;
    // expect the same number of variables at each prime
    assert #{Rank(Universe(rs)) : rs in reductions} eq 1;
    // and the same type
    assert #{Type(Universe(rs)) : rs in reductions} eq 1;
    exps := {@ Exponents(m) : m in Monomials(r), r in rs, rs in reductions @};
    coeffs := [
        Matrix(Integers(), [[ MonomialCoefficient(r, exp) : exp in exps] : r in rs])
        : rs in reductions ];
    b, rr := FractionalCRTSplitMatrix(coeffs, primes);
    if not b then
        return false, _;
    end if;
    // this creates the (uni)multivariate polynomial
    Rprod := ChangeRing(Universe(reductions[1]), BaseRing(rr));
    res := [ &+[Rprod |  Monomial(Rprod, exp)*rr[i,j] : j->exp in exps ] : i->_ in reductions[1] ];
    return true, res;
end function;



function ReduceConstantSplit(x, h)

return h(x);

end function;


function ReducePointSplit(P, h);

return [ ReduceConstantSplit(c, h) : c in Eltseq(P) ];

end function;


function ReduceMatrixSplit(M, h);

return Matrix(Codomain(h), [ [ ReduceConstantSplit(c, h) : c in Eltseq(row) ] : row in Rows(M) ]);

end function;


function ReducePolynomialSplit(f, h)

FF := Codomain(h); R_red := PolynomialRing(FF, Rank(Parent(f)));
f_red := &+[ ReduceConstantSplit(MonomialCoefficient(f, mon), h) * Monomial(R_red, Exponents(mon)) : mon in Monomials(f) ];
// Magma subtlety: we have to coerce to a univariate polynomial ring instead of
// a multivariate ring in one variable
if Rank(Parent(f)) eq 1 then
    return PolynomialRing(FF) ! f_red;
end if;
return f_red;

end function;


function ReduceRationalFunctionSplit(q, h)

FF := Codomain(h); R_red := PolynomialRing(FF, Rank(Parent(q))); K_red := FieldOfFractions(R_red);
num_red := R_red ! ReducePolynomialSplit(Numerator(q), h);
den_red := R_red ! ReducePolynomialSplit(Denominator(q), h);
return K_red ! (num_red / den_red);

end function;


function ReduceBasisOfDifferentialsSplit(B, h)

// Recall that we consider differentials as rational functions by fixing a
// uniformizer in a canonical way
FF := Codomain(h); K_red := RationalFunctionField(FF, Rank(Parent(B[1])));
return [ K_red ! ReduceRationalFunctionSplit(b, h) : b in B ];

end function;


function ReduceAffinePatchSplit(X, h)

FF := Codomain(h); R_red := PolynomialRing(FF, Rank(CoordinateRing(Ambient(X))));
DEs_red := [ R_red ! ReducePolynomialSplit(DE, h) : DE in DefiningEquations(X) ];
return Curve(Scheme(AffineSpace(R_red), DEs_red));

end function;


function ReduceCurveSplit(X, h)
/* NOTE: This only gives an affine patch (which is enough for our algorithms) */

U := ReduceAffinePatchSplit(X`U, h); U`U := U;
U`is_hyperelliptic := X`is_hyperelliptic; U`is_planar := X`is_planar; U`is_smooth := X`is_smooth;
U`g := X`g; U`is_plane_quartic := X`is_plane_quartic;
U`P0 := U ! ReducePointSplit(X`P0, h);
U`A := Ambient(U`U); U`RA := CoordinateRing(U`A); U`KA := FieldOfFractions(U`RA);
U`RU := CoordinateRing(U`U); U`KU := FunctionField(U`U); U`F := BaseRing(U`RU);
U`unif_index := X`unif_index;
U`DEs := DefiningEquations(U`U);
U`OurB := ReduceBasisOfDifferentialsSplit(X`OurB, h);
U`NormB := ReduceBasisOfDifferentialsSplit(X`NormB, h);
U`T := ReduceMatrixSplit(X`T, h);
U`echelon_exps := X`echelon_exps;
U`cantor_eqs := [* ReducePolynomialSplit(cantor_eq, h) : cantor_eq in X`cantor_eqs *];
if assigned X`RRgens then
    nums := [ U`KU ! U`KA ! Numerator(ReduceRationalFunctionSplit(X`KA ! gen, h)) : gen in X`RRgens ];
    dens := [ U`KU ! U`KA ! Denominator(ReduceRationalFunctionSplit(X`KA ! gen, h)) : gen in X`RRgens ];
    U`RRgens := [ nums[i]/dens[i] : i in [1..#X`RRgens] ];
end if;
if assigned X`globgens then U`globgens := [ U`RA ! ReducePolynomialSplit(gen, h) : gen in X`globgens ]; end if;
if assigned X`DEs_sub then U`DEs_sub := [ U`RA ! ReducePolynomialSplit(f, h) : f in X`DEs_sub ]; end if;
U`initialized := true;
return U;

end function;
